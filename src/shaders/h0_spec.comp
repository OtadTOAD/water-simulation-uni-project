#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D noise_texture;
layout(set = 0, binding = 1, rgba32f) uniform writeonly image2D outputImage;

layout(push_constant) uniform PushConstants {
    vec2 windDirection;
    float windSpeed;
    float amplitude;
    float gridSize;
    float gravity;
} params;

const float PI = 3.14159265359;
const float TAU = PI * 2.0; 
const float INV_SQRT_2 = 0.70710678118;// 1/sqrt(2)
const float WIND_RESISTANCE_MULT = 0.25;

float phillipsSpectrum(vec2 k, float k_length) {
    // L = largest possible wave from wind (V^2 / g)
    float L = params.windSpeed * params.windSpeed / params.gravity;
    
    vec2 windDir = normalize(params.windDirection);    
    vec2 unit_k = k / k_length;
    
    
    // P(k) = A * exp(-1/(kL)^2) / k^4 * |kÂ·w|^2
    float k_length_sq = k_length * k_length;
    float L_sq = L * L;
    
    float exp_term = exp(-1.0 / (k_length_sq * L_sq));
    float k_pow4 = k_length_sq * k_length_sq;
    
    float k_dot_w = dot(unit_k, windDir);// waves aligned with wind are stronger
    float phillips = params.amplitude * exp_term / k_pow4 * (k_dot_w * k_dot_w);
    
    // Wave is going against wind direction
    if (k_dot_w < 0.0) {
        phillips *= WIND_RESISTANCE_MULT;
    }
    
    // Suppress very small waves(Otherwise we get small ripples everywhere)
    float l = L * 0.001;
    phillips *= exp(-k_length_sq * l * l);
    return phillips;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);
    int N = imageSize.x;
    if (pixel.x >= N || pixel.y >= N) {
        return;
    }

    // Centered coords
    float n = float(pixel.x) - float(N) / 2.0;
    float m = float(pixel.y) - float(N) / 2.0;

    float L = params.gridSize;// Patch size in world units
    vec2 k = vec2(TAU * n / L, TAU * m / L);
    float k_length = length(k);
    if (k_length < 0.0001) {
        imageStore(outputImage, pixel, vec4(0.0));
        return;
    }

    float phillips = phillipsSpectrum(k, k_length);
    float phillips_sqrt = sqrt(phillips);

    // Sample Gaussian noise from texture
    // Noise texture contains [real1, imag1, real2, imag2] as Gaussian random numbers
    vec2 uv = (vec2(pixel) + 0.5) / vec2(N);
    vec4 noise = texture(noise_texture, uv);
    
    // noise.rg = gaussian for h0(k)
    // noise.ba = gaussian for h0(-k)*
    float h0_real = INV_SQRT_2 * noise.r * phillips_sqrt;
    float h0_imag = INV_SQRT_2 * noise.g * phillips_sqrt;

    float h0_conj_real = INV_SQRT_2 * noise.b * phillips_sqrt;
    float h0_conj_imag = INV_SQRT_2 * noise.a * phillips_sqrt;

    // R = h0_real, G = h0_imag, B = h0_conj_real, A = h0_conj_imag
    imageStore(outputImage, pixel, vec4(h0_real, h0_imag, h0_conj_real, h0_conj_imag));
}