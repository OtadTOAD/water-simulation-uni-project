#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba32f) uniform writeonly image2D outputImage;

layout(set = 0, binding = 1) uniform SimParams {
    vec2 windDirection;
    float windSpeed;
    float amplitude;
    float gridSize;
    float gravity;
} params;

const float PI = 3.14159265359;
const float TAU = PI * 2.0; 
const float INV_SQRT_2 = 0.70710678118;// 1/sqrt(2)
const float WIND_RESISTANCE_MULT = 0.25;

// Returns value in range [0, 1]
float hash(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

vec4 hash4(vec2 p) {
    return vec4(
        hash(p),
        hash(p + vec2(127.1, 311.7)),
        hash(p + vec2(269.5, 183.3)),
        hash(p + vec2(419.2, 371.9))
    );
}

// Convert uniform random [0,1] to Gaussian (mean=0, std=1)
// Takes two uniform random numbers, outputs two Gaussian random numbers
vec2 boxMuller(float u1, float u2) {
    // Avoid log(0)
    u1 = max(u1, 0.0001);
    
    float r = sqrt(-2.0 * log(u1));
    float theta = TAU * u2;
    
    return vec2(r * cos(theta), r * sin(theta));
}

float phillipsSpectrum(vec2 k, float k_length) {
    // L = largest possible wave from wind (V^2 / g)
    float L = params.windSpeed * params.windSpeed / params.gravity;
    
    vec2 windDir = normalize(params.windDirection);    
    vec2 unit_k = k / k_length;
    
    
    // P(k) = A * exp(-1/(kL)^2) / k^4 * |kÂ·w|^2
    float k_length_sq = k_length * k_length;
    float L_sq = L * L;
    
    float exp_term = exp(-1.0 / (k_length_sq * L_sq));
    float k_pow4 = k_length_sq * k_length_sq;
    
    float k_dot_w = dot(unit_k, windDir);// waves aligned with wind are stronger
    float phillips = params.amplitude * exp_term / k_pow4 * (k_dot_w * k_dot_w);
    
    // Wave is going against wind direction
    if (k_dot_w < 0.0) {
        phillips *= WIND_RESISTANCE_MULT;
    }
    
    // Suppress very small waves(Otherwise we get small ripples everywhere)
    float l = L * 0.001;
    phillips *= exp(-k_length_sq * l * l);
    return phillips;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);
    int N = imageSize.x;
    if (pixel.x >= N || pixel.y >= N) {// Idk if bounds check is needed, but just in case
        return;
    }

    // Centered coords
    float n = float(pixel.x) - float(N) / 2.0;
    float m = float(pixel.y) - float(N) / 2.0;

    float L = params.gridSize;// Patch size in world units
    vec2 k = vec2(TAU * n / L, TAU * m / L);
    float k_length = length(k);
    if (k_length < 0.0001) {
        imageStore(outputImage, pixel, vec4(0.0));
        return;
    }


    float phillips = phillipsSpectrum(k, k_length);
    float phillips_sqrt = sqrt(phillips);

    vec4 rnd = hash4(vec2(pixel));
    vec2 gaussian1 = boxMuller(rnd.x, rnd.y);// For h0(k)
    vec2 gaussian2 = boxMuller(rnd.z, rnd.w);// For h0(-k)*

    float h0_real = INV_SQRT_2 * gaussian1.x * phillips_sqrt;
    float h0_imag = INV_SQRT_2 * gaussian1.y * phillips_sqrt;

    float h0_conj_real = INV_SQRT_2 * gaussian2.x * phillips_sqrt;
    float h0_conj_imag = INV_SQRT_2 * gaussian2.y * phillips_sqrt;

    // R = h0_real, G = h0_imag, B = h0_conj_real, A = h0_conj_imag
    imageStore(outputImage, pixel, vec4(h0_real, h0_imag, h0_conj_real, h0_conj_imag));
}

